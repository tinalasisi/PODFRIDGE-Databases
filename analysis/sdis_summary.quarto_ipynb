{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"SDIS Summary Analysis\"\n",
        "author: \"Tina Lasisi\"\n",
        "date: today\n",
        "format:\n",
        "  html:\n",
        "    code-fold: false\n",
        "    toc: true\n",
        "execute:\n",
        "  echo: true\n",
        "  warning: false\n",
        "---\n",
        "\n",
        "\n",
        "## Overview\n",
        "\n",
        "This analysis examines State DNA Index System (SDIS) data that includes information reported separately for each state's DNA database. The data captures key dimensions including:\n",
        "\n",
        "- Total size of each state's DNA database\n",
        "- Whether states collect DNA from arrestees (not just convicted offenders)\n",
        "- Whether states allow familial DNA searching\n",
        "- References to relevant state statutes (from Murphy & Tong appendix)\n",
        "\n",
        "This information provides insight into the variation in DNA database policies, practices, and legal frameworks across U.S. states.\n",
        "\n",
        "## Data Loading\n"
      ],
      "id": "153cc27c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import pandas as pd\n",
        "import numpy as np\n",
        "from pathlib import Path\n",
        "\n",
        "# Set up path to data file\n",
        "base_dir = Path(\"..\")\n",
        "data_file = base_dir / \"output\" / \"sdis\" / \"sdis_raw.csv\"\n",
        "\n",
        "# Load the SDIS data\n",
        "sdis_data = pd.read_csv(data_file)\n",
        "\n",
        "print(f\"Loaded SDIS data: {len(sdis_data)} rows\")\n",
        "print(f\"Columns: {list(sdis_data.columns)}\")\n",
        "\n",
        "# Display first few rows\n",
        "display(sdis_data.head())\n",
        "\n",
        "# Display data types for each column\n",
        "print(\"\\nData types:\")\n",
        "display(sdis_data.dtypes)"
      ],
      "id": "ea5d7104",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Data Preprocessing\n",
        "\n",
        "This section ensures data consistency between arrestee collection policies and reported arrestee counts. States that do not collect arrestee DNA (arrestee_collection = 'no') should have N_arrestees set to zero to avoid data inconsistencies.\n"
      ],
      "id": "fb762740"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Create a copy of the data for processing\n",
        "sdis_data_processed = sdis_data.copy()\n",
        "\n",
        "# Count states affected by this adjustment\n",
        "states_with_no_collection = sdis_data_processed[sdis_data_processed['arrestee_collection'] == 'no']\n",
        "states_to_adjust = states_with_no_collection[states_with_no_collection['n_arrestees'].notna() & (states_with_no_collection['n_arrestees'] != 0)]\n",
        "\n",
        "if len(states_to_adjust) > 0:\n",
        "    print(f\"States with arrestee_collection='no' but non-zero n_arrestees values:\")\n",
        "    for _, state in states_to_adjust.iterrows():\n",
        "        print(f\"  • {state['state']}: n_arrestees = {state['n_arrestees']:,.0f}\")\n",
        "\n",
        "# Set n_arrestees to 0 for states that don't collect arrestee DNA\n",
        "sdis_data_processed.loc[sdis_data_processed['arrestee_collection'] == 'no', 'n_arrestees'] = 0\n",
        "\n",
        "print(f\"\\nAdjusted N_arrestees to 0 for {len(states_with_no_collection)} states that do not collect arrestee DNA\")\n",
        "\n",
        "# Use processed data for all subsequent analyses\n",
        "sdis_data = sdis_data_processed"
      ],
      "id": "b0bcb3a0",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Data Availability Overview\n",
        "\n",
        "This section provides an overview of states represented in the dataset and the completeness of data fields across states.\n"
      ],
      "id": "d3242f16"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import matplotlib.pyplot as plt\n",
        "import seaborn as sns\n",
        "\n",
        "# Identify states present in the dataset\n",
        "states_in_data = sdis_data['state'].unique()\n",
        "states_in_data = sorted(states_in_data)\n",
        "print(f\"Number of states with data: {len(states_in_data)}\")\n",
        "\n",
        "# Check if all 50 states are represented\n",
        "all_states = ['Alabama', 'Alaska', 'Arizona', 'Arkansas', 'California', 'Colorado', 'Connecticut',\n",
        "              'Delaware', 'Florida', 'Georgia', 'Hawaii', 'Idaho', 'Illinois', 'Indiana', 'Iowa',\n",
        "              'Kansas', 'Kentucky', 'Louisiana', 'Maine', 'Maryland', 'Massachusetts', 'Michigan',\n",
        "              'Minnesota', 'Mississippi', 'Missouri', 'Montana', 'Nebraska', 'Nevada', 'New Hampshire',\n",
        "              'New Jersey', 'New Mexico', 'New York', 'North Carolina', 'North Dakota', 'Ohio',\n",
        "              'Oklahoma', 'Oregon', 'Pennsylvania', 'Rhode Island', 'South Carolina', 'South Dakota',\n",
        "              'Tennessee', 'Texas', 'Utah', 'Vermont', 'Virginia', 'Washington', 'West Virginia',\n",
        "              'Wisconsin', 'Wyoming']\n",
        "\n",
        "missing_states = [state for state in all_states if state not in states_in_data]\n",
        "if missing_states:\n",
        "    print(f\"\\nMissing states: {', '.join(missing_states)}\")\n",
        "else:\n",
        "    print(\"\\nAll 50 states are represented in the dataset\")\n",
        "\n",
        "# Assess data completeness for each state\n",
        "data_availability = pd.DataFrame(index=states_in_data)\n",
        "\n",
        "for col in sdis_data.columns:\n",
        "    if col != 'state':  # Exclude the state identifier column\n",
        "        # Calculate non-null values per state\n",
        "        availability = sdis_data.groupby('state')[col].apply(lambda x: x.notna().sum())\n",
        "        data_availability[col] = availability\n",
        "\n",
        "# Generate visualization of data completeness\n",
        "if len(data_availability.columns) > 0:\n",
        "    # Focus on key numeric and policy fields\n",
        "    key_fields = ['n_total', 'n_arrestees', 'n_offenders', 'n_forensic', \n",
        "                  'arrestee_collection', 'fam_search']\n",
        "    \n",
        "    # Filter to include only key fields that exist in the data\n",
        "    available_key_fields = [f for f in key_fields if f in data_availability.columns]\n",
        "    \n",
        "    if available_key_fields:\n",
        "        plt.figure(figsize=(10, 14))\n",
        "        \n",
        "        # Create binary matrix for visualization\n",
        "        availability_subset = data_availability[available_key_fields]\n",
        "        availability_binary = (availability_subset > 0).astype(int)\n",
        "        \n",
        "        # Generate heatmap\n",
        "        sns.heatmap(availability_binary, \n",
        "                    cmap=['#f0f0f0', '#2E86AB'],\n",
        "                    cbar=False,  # Remove colorbar for binary data\n",
        "                    linewidths=0.5,\n",
        "                    linecolor='gray',\n",
        "                    square=True,\n",
        "                    vmin=0, vmax=1)\n",
        "        \n",
        "        plt.title('Data Availability by State', fontsize=14, pad=20)\n",
        "        plt.xlabel('Data Fields', fontsize=12)\n",
        "        plt.ylabel('States', fontsize=12)\n",
        "        plt.xticks(rotation=45, ha='right')\n",
        "        \n",
        "        # Add annotations for clarity\n",
        "        for i in range(len(availability_binary)):\n",
        "            for j in range(len(availability_binary.columns)):\n",
        "                if availability_binary.iloc[i, j] == 1:\n",
        "                    plt.text(j + 0.5, i + 0.5, '✓', ha='center', va='center', \n",
        "                            fontsize=8, color='white', fontweight='bold')\n",
        "        \n",
        "        plt.tight_layout()\n",
        "        plt.show()\n",
        "        \n",
        "        print(f\"\\nTotal states shown in heatmap: {len(availability_binary)}\")\n",
        "\n",
        "# Data coverage summary\n",
        "print(f\"\\nData field coverage across states:\")\n",
        "\n",
        "# Focus on key fields\n",
        "key_fields = ['n_total', 'n_arrestees', 'n_offenders', 'n_forensic', \n",
        "              'arrestee_collection', 'fam_search', 'collection_statute']\n",
        "\n",
        "for col in key_fields:\n",
        "    if col in data_availability.columns:\n",
        "        states_with_data = (data_availability[col] > 0).sum()\n",
        "        coverage_pct = states_with_data/len(states_in_data)*100\n",
        "        print(f\"{col}: {states_with_data} states ({coverage_pct:.1f}%)\")"
      ],
      "id": "27f1c49a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Total Profile Calculations Verification\n",
        "\n",
        "This section examines states reporting n_total alongside component counts to determine whether totals represent:\n",
        "1. Sum of all profile types including forensic (n_arrestees + n_offenders + n_forensic)\n",
        "2. Sum of combined profiles only (n_arrestees + n_offenders)\n"
      ],
      "id": "c580fbcf"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Note: This analysis uses the original data before renaming columns\n",
        "# Create a temporary copy with the original column name for this analysis\n",
        "sdis_data_temp = sdis_data.copy()\n",
        "if 'n_total_reported' in sdis_data_temp.columns and 'n_total' not in sdis_data_temp.columns:\n",
        "    sdis_data_temp['n_total'] = sdis_data_temp['n_total_reported']\n",
        "\n",
        "# Identify states with n_total and at least one component count\n",
        "states_with_totals = sdis_data_temp[sdis_data_temp['n_total'].notna()].copy()\n",
        "\n",
        "# Calculate different possible sums\n",
        "states_with_totals['sum_all'] = states_with_totals[['n_arrestees', 'n_offenders', 'n_forensic']].sum(axis=1, skipna=True)\n",
        "states_with_totals['sum_forensic'] = states_with_totals[['n_arrestees', 'n_offenders']].sum(axis=1, skipna=True)\n",
        "\n",
        "# Check which sum matches n_total (with small tolerance for rounding)\n",
        "tolerance = 10  # Allow small differences due to rounding or timing\n",
        "\n",
        "# Check matches_combined_forensic - will be False if any component is missing\n",
        "states_with_totals['matches_combined_forensic'] = np.where(\n",
        "    states_with_totals[['n_arrestees', 'n_offenders', 'n_forensic']].notna().all(axis=1),\n",
        "    abs(states_with_totals['n_total'] - states_with_totals['sum_all']) <= tolerance,\n",
        "    False\n",
        ")\n",
        "\n",
        "# Check matches_combined - will be False if n_arrestees or n_offenders is missing\n",
        "# Additional condition: only True if arrestee_collection is 'no' OR n_arrestees > 0\n",
        "states_with_totals['matches_combined'] = np.where(\n",
        "    states_with_totals[['n_arrestees', 'n_offenders']].notna().all(axis=1),\n",
        "    (abs(states_with_totals['n_total'] - states_with_totals['sum_forensic']) <= tolerance) & \n",
        "    ((states_with_totals['arrestee_collection'] == 'no') | (states_with_totals['n_arrestees'] > 0)),\n",
        "    False\n",
        ")\n",
        "\n",
        "# Create summary dataframe for display\n",
        "total_verification = states_with_totals[['state', 'n_total', 'n_arrestees', 'n_offenders', 'n_forensic', \n",
        "                                        'arrestee_collection', 'sum_all', 'sum_forensic', \n",
        "                                        'matches_combined_forensic', 'matches_combined']].copy()\n",
        "\n",
        "# Filter to states with at least one component count\n",
        "has_components = total_verification[\n",
        "    (total_verification['n_arrestees'].notna()) | \n",
        "    (total_verification['n_offenders'].notna()) | \n",
        "    (total_verification['n_forensic'].notna())\n",
        "]\n",
        "\n",
        "print(f\"States with n_total and component data: {len(has_components)}\")\n",
        "print(\"\\nTotal calculation patterns:\")\n",
        "\n",
        "# Categorize states\n",
        "includes_all = has_components[has_components['matches_combined_forensic'] == True]['state'].tolist()\n",
        "forensic_only = has_components[(has_components['matches_combined'] == True) & (has_components['matches_combined_forensic'] == False)]['state'].tolist()\n",
        "neither = has_components[(has_components['matches_combined_forensic'] == False) & (has_components['matches_combined'] == False)]['state'].tolist()\n",
        "\n",
        "if includes_all:\n",
        "    print(f\"\\nn_total includes combined profiles with forensic (arrestees + offenders + forensic):\")\n",
        "    for state in includes_all:\n",
        "        print(f\"  • {state}\")\n",
        "\n",
        "if forensic_only:\n",
        "    print(f\"\\nn_total includes combined profiles only (arrestees + offenders):\")\n",
        "    for state in forensic_only:\n",
        "        print(f\"  • {state}\")\n",
        "\n",
        "if neither:\n",
        "    print(f\"\\nn_total does not match calculated sums:\")\n",
        "    for state in neither:\n",
        "        state_data = has_components[has_components['state'] == state].iloc[0]\n",
        "        print(f\"  • {state}: n_total={state_data['n_total']:,.0f}, \"\n",
        "              f\"Sum_all={state_data['sum_all']:,.0f}, \"\n",
        "              f\"Sum_forensic={state_data['sum_forensic']:,.0f}\")\n",
        "\n",
        "# Display detailed breakdown for verification\n",
        "print(\"\\nDetailed breakdown:\")\n",
        "display(has_components[['state', 'n_total', 'n_arrestees', 'n_offenders', 'n_forensic', \n",
        "                       'arrestee_collection', 'matches_combined_forensic', 'matches_combined']].style.format({\n",
        "    'n_total': '{:,.0f}',\n",
        "    'n_arrestees': lambda x: '{:,.0f}'.format(x) if pd.notna(x) else '',\n",
        "    'n_offenders': lambda x: '{:,.0f}'.format(x) if pd.notna(x) else '',\n",
        "    'n_forensic': lambda x: '{:,.0f}'.format(x) if pd.notna(x) else ''\n",
        "}))"
      ],
      "id": "4f37f1e1",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Analysis of Database Totals and Data Quality Issues\n",
        "\n",
        "This section examines states where N_total values reveal potential data quality issues or reporting inconsistencies.\n"
      ],
      "id": "1f8b006a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Create enhanced data quality analysis\n",
        "sdis_enhanced = sdis_data.copy()\n",
        "\n",
        "# Rename n_total to n_total_reported\n",
        "sdis_enhanced = sdis_enhanced.rename(columns={'n_total': 'n_total_reported'})\n",
        "\n",
        "# Calculate different total relationships with small tolerance\n",
        "tolerance = 10\n",
        "\n",
        "# Check if n_total equals different combinations\n",
        "# Note: Only consider values > 0 as valid data (0 means no data)\n",
        "# For offenders only: either arrestees are missing/zero OR state doesn't collect arrestees\n",
        "sdis_enhanced['total_equals_offenders'] = np.where(\n",
        "    sdis_enhanced['n_total_reported'].notna() & \n",
        "    sdis_enhanced['n_offenders'].notna() & \n",
        "    (sdis_enhanced['n_offenders'] > 0),\n",
        "    abs(sdis_enhanced['n_total_reported'] - sdis_enhanced['n_offenders']) <= tolerance,\n",
        "    False\n",
        ")\n",
        "\n",
        "sdis_enhanced['total_equals_off_arr'] = np.where(\n",
        "    sdis_enhanced['n_total_reported'].notna() & \n",
        "    sdis_enhanced['n_offenders'].notna() & \n",
        "    sdis_enhanced['n_arrestees'].notna() &\n",
        "    (sdis_enhanced['n_offenders'] > 0) &\n",
        "    (sdis_enhanced['n_arrestees'] > 0),\n",
        "    abs(sdis_enhanced['n_total_reported'] - (sdis_enhanced['n_offenders'] + sdis_enhanced['n_arrestees'])) <= tolerance,\n",
        "    False\n",
        ")\n",
        "\n",
        "sdis_enhanced['total_equals_all'] = np.where(\n",
        "    sdis_enhanced['n_total_reported'].notna() & \n",
        "    sdis_enhanced['n_offenders'].notna() & \n",
        "    sdis_enhanced['n_arrestees'].notna() & \n",
        "    sdis_enhanced['n_forensic'].notna() &\n",
        "    (sdis_enhanced['n_offenders'] > 0) &\n",
        "    (sdis_enhanced['n_arrestees'] > 0) &\n",
        "    (sdis_enhanced['n_forensic'] > 0),\n",
        "    abs(sdis_enhanced['n_total_reported'] - (sdis_enhanced['n_offenders'] + sdis_enhanced['n_arrestees'] + sdis_enhanced['n_forensic'])) <= tolerance,\n",
        "    False\n",
        ")\n",
        "\n",
        "# Determine total calculation method for each state\n",
        "# Use priority order: All components > Offenders + Arrestees > Offenders only\n",
        "sdis_enhanced['total_method'] = 'Unknown'\n",
        "sdis_enhanced.loc[sdis_enhanced['total_equals_offenders'], 'total_method'] = 'Offenders only'\n",
        "sdis_enhanced.loc[sdis_enhanced['total_equals_off_arr'], 'total_method'] = 'Offenders + Arrestees'\n",
        "sdis_enhanced.loc[sdis_enhanced['total_equals_all'], 'total_method'] = 'All components'\n",
        "\n",
        "# Create n_total_estimated based on the rules specified\n",
        "sdis_enhanced['n_total_estimated'] = np.nan\n",
        "sdis_enhanced['n_total_estimated_comment'] = ''\n",
        "\n",
        "# Rule 1: States where n_total == n_offenders + n_arrestees\n",
        "mask_off_arr = sdis_enhanced['total_equals_off_arr']\n",
        "sdis_enhanced.loc[mask_off_arr, 'n_total_estimated'] = sdis_enhanced.loc[mask_off_arr, 'n_total_reported']\n",
        "sdis_enhanced.loc[mask_off_arr, 'n_total_estimated_comment'] = 'Used reported total (matches offenders + arrestees)'\n",
        "\n",
        "# Rule 2: States where n_total == n_offenders + n_arrestees + n_forensic\n",
        "mask_all = sdis_enhanced['total_equals_all']\n",
        "sdis_enhanced.loc[mask_all, 'n_total_estimated'] = (\n",
        "    sdis_enhanced.loc[mask_all, 'n_total_reported'] - sdis_enhanced.loc[mask_all, 'n_forensic']\n",
        ")\n",
        "sdis_enhanced.loc[mask_all, 'n_total_estimated_comment'] = 'Subtracted forensic from reported total'\n",
        "\n",
        "# Rule 3: States where n_total == n_offenders\n",
        "# This includes states that don't collect arrestees OR states where total just happens to equal offenders\n",
        "mask_off_only = sdis_enhanced['total_equals_offenders']\n",
        "sdis_enhanced.loc[mask_off_only, 'n_total_estimated'] = sdis_enhanced.loc[mask_off_only, 'n_total_reported']\n",
        "sdis_enhanced.loc[mask_off_only, 'n_total_estimated_comment'] = 'Used reported total (matches offenders only)'\n",
        "\n",
        "# Rule 4: For remaining states with n_total\n",
        "# First check if they have ONLY total (no component breakdown)\n",
        "mask_total_only = (\n",
        "    sdis_enhanced['n_total_reported'].notna() & \n",
        "    sdis_enhanced['n_total_estimated'].isna() &\n",
        "    (sdis_enhanced['n_arrestees'].isna() | (sdis_enhanced['n_arrestees'] == 0)) &\n",
        "    (sdis_enhanced['n_offenders'].isna() | (sdis_enhanced['n_offenders'] == 0)) &\n",
        "    (sdis_enhanced['n_forensic'].isna() | (sdis_enhanced['n_forensic'] == 0))\n",
        ")\n",
        "sdis_enhanced.loc[mask_total_only, 'n_total_estimated'] = sdis_enhanced.loc[mask_total_only, 'n_total_reported']\n",
        "sdis_enhanced.loc[mask_total_only, 'n_total_estimated_comment'] = 'Total only reported (no breakdown available)'\n",
        "\n",
        "# Special case: States like California with n_total and n_forensic only\n",
        "# (no offenders/arrestees breakdown)\n",
        "mask_total_forensic_only = (\n",
        "    sdis_enhanced['n_total_reported'].notna() & \n",
        "    sdis_enhanced['n_total_estimated'].isna() &\n",
        "    (sdis_enhanced['n_arrestees'].isna() | (sdis_enhanced['n_arrestees'] == 0)) &\n",
        "    (sdis_enhanced['n_offenders'].isna() | (sdis_enhanced['n_offenders'] == 0)) &\n",
        "    sdis_enhanced['n_forensic'].notna() & (sdis_enhanced['n_forensic'] > 0)\n",
        ")\n",
        "sdis_enhanced.loc[mask_total_forensic_only, 'n_total_estimated'] = sdis_enhanced.loc[mask_total_forensic_only, 'n_total_reported']\n",
        "sdis_enhanced.loc[mask_total_forensic_only, 'n_total_estimated_comment'] = 'Total only reported (forensic reported separately)'\n",
        "\n",
        "# States with total and some components but unclear calculation\n",
        "mask_has_total_unclear = (\n",
        "    sdis_enhanced['n_total_reported'].notna() & \n",
        "    sdis_enhanced['n_total_estimated'].isna()\n",
        ")\n",
        "sdis_enhanced.loc[mask_has_total_unclear, 'n_total_estimated'] = sdis_enhanced.loc[mask_has_total_unclear, 'n_total_reported']\n",
        "sdis_enhanced.loc[mask_has_total_unclear, 'n_total_estimated_comment'] = 'Total with discrepancy (calculation unclear)'\n",
        "\n",
        "# For states without any total but with offenders and arrestees (both > 0)\n",
        "mask_no_total = (\n",
        "    sdis_enhanced['n_total_reported'].isna() & \n",
        "    sdis_enhanced['n_offenders'].notna() & (sdis_enhanced['n_offenders'] > 0) &\n",
        "    sdis_enhanced['n_arrestees'].notna() & (sdis_enhanced['n_arrestees'] > 0)\n",
        ")\n",
        "sdis_enhanced.loc[mask_no_total, 'n_total_estimated'] = (\n",
        "    sdis_enhanced.loc[mask_no_total, 'n_offenders'] + sdis_enhanced.loc[mask_no_total, 'n_arrestees']\n",
        ")\n",
        "sdis_enhanced.loc[mask_no_total, 'n_total_estimated_comment'] = 'Calculated from offenders + arrestees (no total reported)'\n",
        "\n",
        "# For states without total but with only offenders > 0\n",
        "mask_no_total_off_only = (\n",
        "    sdis_enhanced['n_total_reported'].isna() & \n",
        "    sdis_enhanced['n_offenders'].notna() & (sdis_enhanced['n_offenders'] > 0) &\n",
        "    (sdis_enhanced['n_arrestees'].isna() | (sdis_enhanced['n_arrestees'] == 0))\n",
        ")\n",
        "sdis_enhanced.loc[mask_no_total_off_only, 'n_total_estimated'] = sdis_enhanced.loc[mask_no_total_off_only, 'n_offenders']\n",
        "sdis_enhanced.loc[mask_no_total_off_only, 'n_total_estimated_comment'] = 'Used offenders count (no total reported, no arrestee data)'\n",
        "\n",
        "# Create data availability matrix for heatmap\n",
        "# Treat 0 values as missing data\n",
        "availability_matrix = pd.DataFrame({\n",
        "    'State': sdis_enhanced['state'],\n",
        "    'Arrestees': (sdis_enhanced['n_arrestees'].notna() & (sdis_enhanced['n_arrestees'] > 0)),\n",
        "    'Offenders': (sdis_enhanced['n_offenders'].notna() & (sdis_enhanced['n_offenders'] > 0)),\n",
        "    'Forensic': (sdis_enhanced['n_forensic'].notna() & (sdis_enhanced['n_forensic'] > 0)),\n",
        "    'Total Reported': sdis_enhanced['n_total_reported'].notna(),\n",
        "    'Total Method': sdis_enhanced['total_method']\n",
        "})\n",
        "\n",
        "# Summary of how n_total_estimated was calculated\n",
        "print(\"n_total_estimated Calculation Summary:\")\n",
        "print(\"=\" * 50)\n",
        "\n",
        "# Create single plot with better dimensions\n",
        "fig, ax = plt.subplots(figsize=(10, 16)) \n",
        "\n",
        "# Prepare data for combined heatmap\n",
        "# Data availability columns\n",
        "availability_binary = availability_matrix.set_index('State')[['Arrestees', 'Offenders', 'Forensic', 'Total Reported']].astype(int)\n",
        "\n",
        "# Add total method as a numeric column\n",
        "method_mapping = {\n",
        "    'Unknown': 0,\n",
        "    'Offenders only': 1,\n",
        "    'Offenders + Arrestees': 2,\n",
        "    'All components': 3\n",
        "}\n",
        "availability_binary['Total Method'] = availability_matrix.set_index('State')['Total Method'].replace(method_mapping)\n",
        "\n",
        "# Create custom colormap for the combined heatmap\n",
        "from matplotlib.colors import ListedColormap\n",
        "import matplotlib.patches as patches\n",
        "\n",
        "# Create the heatmap\n",
        "sns.heatmap(availability_binary.iloc[:, :4],  # First 4 columns (binary data)\n",
        "            cmap=['#f0f0f0', '#2E86AB'],\n",
        "            cbar=False,\n",
        "            linewidths=0.5,\n",
        "            linecolor='gray',\n",
        "            square=True,\n",
        "            ax=ax)  # Changed from ax1 to ax\n",
        "\n",
        "# Add the Total Method column with a different colormap\n",
        "x_pos = 4\n",
        "method_colors = ['#f0f0f0', '#FF6B6B', '#4ECDC4', '#45B7D1']\n",
        "for i, (idx, row) in enumerate(availability_binary.iterrows()):\n",
        "    method_val = int(row['Total Method'])\n",
        "    rect = patches.Rectangle((x_pos, i), 1, 1, \n",
        "                           linewidth=0.5, \n",
        "                           edgecolor='gray',\n",
        "                           facecolor=method_colors[method_val])\n",
        "    ax.add_patch(rect)  # Changed from ax1 to ax\n",
        "\n",
        "# Update x-axis labels\n",
        "column_labels = list(availability_binary.columns)\n",
        "ax.set_xticks(np.arange(len(column_labels)) + 0.5)  # Changed from ax1 to ax\n",
        "ax.set_xticklabels(column_labels, rotation=45, ha='right')  # Changed from ax1 to ax\n",
        "\n",
        "# Add checkmarks for binary columns\n",
        "for i in range(len(availability_binary)):\n",
        "    for j in range(4):  # Only first 4 columns\n",
        "        if availability_binary.iloc[i, j] == 1:\n",
        "            ax.text(j + 0.5, i + 0.5, '✓', ha='center', va='center',  # Changed from ax1 to ax\n",
        "                   fontsize=8, color='white', fontweight='bold')\n",
        "\n",
        "# Add method labels for the Total Method column\n",
        "method_labels = ['?', 'O', 'O+A', 'All']\n",
        "for i in range(len(availability_binary)):\n",
        "    method_val = int(availability_binary.iloc[i, 4])\n",
        "    ax.text(4.5, i + 0.5, method_labels[method_val], ha='center', va='center',  # Changed from ax1 to ax\n",
        "           fontsize=8, color='white' if method_val > 0 else 'black', fontweight='bold')\n",
        "\n",
        "ax.set_title('Data Field Availability and Total Calculation Method by State', fontsize=14, pad=20)  # Changed from ax1 to ax\n",
        "ax.set_xlabel('')  # Changed from ax1 to ax\n",
        "ax.set_ylabel('')  # Changed from ax1 to ax\n",
        "\n",
        "# Create legend at the bottom\n",
        "legend_elements = [\n",
        "    patches.Patch(facecolor='#f0f0f0', edgecolor='black', label='Unknown (?)'),\n",
        "    patches.Patch(facecolor='#FF6B6B', edgecolor='black', label='Offenders only (O)'),\n",
        "    patches.Patch(facecolor='#4ECDC4', edgecolor='black', label='Offenders + Arrestees (O+A)'),\n",
        "    patches.Patch(facecolor='#45B7D1', edgecolor='black', label='All components (All)')\n",
        "]\n",
        "\n",
        "# Place legend below the plot\n",
        "ax.legend(handles=legend_elements, \n",
        "          loc='upper center', \n",
        "          bbox_to_anchor=(0.5, -0.02),\n",
        "          ncol=2,\n",
        "          title='Total Method',\n",
        "          frameon=True)\n",
        "\n",
        "# Adjust layout\n",
        "plt.tight_layout()\n",
        "plt.show()\n",
        "\n",
        "# Group states by how their n_total_estimated was determined\n",
        "estimation_groups = sdis_enhanced.groupby('n_total_estimated_comment')['state'].apply(list)\n",
        "\n",
        "print(\"\\n1. States with only n_total reported (no component breakdown):\")\n",
        "if 'Total only reported (no breakdown available)' in estimation_groups:\n",
        "    states = estimation_groups['Total only reported (no breakdown available)']\n",
        "    print(f\"   {len(states)} states: {', '.join(states)}\")\n",
        "if 'Total only reported (forensic reported separately)' in estimation_groups:\n",
        "    states = estimation_groups['Total only reported (forensic reported separately)']\n",
        "    print(f\"   - With forensic reported separately: {len(states)} states ({', '.join(states)})\")\n",
        "\n",
        "print(\"\\n2. States where n_total matches component calculations:\")\n",
        "if 'Used reported total (matches offenders + arrestees)' in estimation_groups:\n",
        "    states = estimation_groups['Used reported total (matches offenders + arrestees)']\n",
        "    print(f\"   - Matches offenders + arrestees: {len(states)} states ({', '.join(states)})\")\n",
        "if 'Subtracted forensic from reported total' in estimation_groups:\n",
        "    states = estimation_groups['Subtracted forensic from reported total']\n",
        "    print(f\"   - Matches all components (forensic subtracted): {len(states)} states ({', '.join(states)})\")\n",
        "if 'Used reported total (matches offenders only)' in estimation_groups:\n",
        "    states = estimation_groups['Used reported total (matches offenders only)']\n",
        "    print(f\"   - Matches offenders only: {len(states)} states ({', '.join(states)})\")\n",
        "\n",
        "print(\"\\n3. States without n_total reported:\")\n",
        "if 'Calculated from offenders + arrestees (no total reported)' in estimation_groups:\n",
        "    states = estimation_groups['Calculated from offenders + arrestees (no total reported)']\n",
        "    print(f\"   - Calculated from offenders + arrestees: {len(states)} states ({', '.join(states)})\")\n",
        "if 'Used offenders count (no total reported, no arrestee data)' in estimation_groups:\n",
        "    states = estimation_groups['Used offenders count (no total reported, no arrestee data)']\n",
        "    print(f\"   - Used offenders as proxy: {len(states)} states ({', '.join(states)})\")\n",
        "\n",
        "print(\"\\n4. States with unclear calculation (total doesn't match expected patterns):\")\n",
        "if 'Total with discrepancy (calculation unclear)' in estimation_groups:\n",
        "    unclear_states = sdis_enhanced[sdis_enhanced['n_total_estimated_comment'] == 'Total with discrepancy (calculation unclear)']\n",
        "    \n",
        "    # Filter to only show states that truly don't match any pattern\n",
        "    states_to_display = []\n",
        "    for _, state in unclear_states.iterrows():\n",
        "        # Calculate different possible sums\n",
        "        sum_offenders = state['n_offenders'] if pd.notna(state['n_offenders']) and state['n_offenders'] > 0 else 0\n",
        "        sum_arrestees = state['n_arrestees'] if pd.notna(state['n_arrestees']) and state['n_arrestees'] > 0 else 0\n",
        "        sum_forensic = state['n_forensic'] if pd.notna(state['n_forensic']) and state['n_forensic'] > 0 else 0\n",
        "        \n",
        "        sum_off_arr = sum_offenders + sum_arrestees\n",
        "        sum_all = sum_offenders + sum_arrestees + sum_forensic\n",
        "        \n",
        "        # Check what the total matches\n",
        "        matches_off = abs(state['n_total_reported'] - sum_offenders) <= tolerance\n",
        "        matches_off_arr = abs(state['n_total_reported'] - sum_off_arr) <= tolerance\n",
        "        matches_all = abs(state['n_total_reported'] - sum_all) <= tolerance\n",
        "        \n",
        "        # Only include states that don't match any expected pattern\n",
        "        if not (matches_off or matches_off_arr or matches_all):\n",
        "            states_to_display.append(state['state'])\n",
        "    \n",
        "    if states_to_display:\n",
        "        print(f\"   {len(states_to_display)} states: {', '.join(states_to_display)}\")\n",
        "        print(\"   (These states have totals that don't match any combination of their component counts)\")\n",
        "\n",
        "# Show full enhanced data for all states\n",
        "print(\"\\n\\nFull Enhanced Data with Estimated Totals (All 50 States):\")\n",
        "cols_to_show = ['state', 'n_total_estimated', 'n_total_reported', 'n_offenders', 'n_arrestees', \n",
        "                'n_forensic', 'n_total_estimated_comment']\n",
        "display(sdis_enhanced[cols_to_show].style.format({\n",
        "    'n_total_estimated': lambda x: '{:,.0f}'.format(x) if pd.notna(x) else '',\n",
        "    'n_total_reported': lambda x: '{:,.0f}'.format(x) if pd.notna(x) else '',\n",
        "    'n_offenders': lambda x: '{:,.0f}'.format(x) if pd.notna(x) else '',\n",
        "    'n_arrestees': lambda x: '{:,.0f}'.format(x) if pd.notna(x) else '',\n",
        "    'n_forensic': lambda x: '{:,.0f}'.format(x) if pd.notna(x) else ''\n",
        "}))\n",
        "\n",
        "# Update the main dataframe for subsequent analyses\n",
        "sdis_data = sdis_enhanced"
      ],
      "id": "b96000c6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Export Enhanced Dataset\n",
        "\n",
        "This section exports the enhanced dataset with the new n_total_estimated values and documentation.\n"
      ],
      "id": "ac6a12bf"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Prepare final dataset with key columns in logical order\n",
        "final_columns = [\n",
        "    'state', \n",
        "    'n_total_estimated',\n",
        "    'n_total_reported',\n",
        "    'n_arrestees', \n",
        "    'n_offenders', \n",
        "    'n_forensic',\n",
        "    'arrestee_collection',\n",
        "    'fam_search',\n",
        "    'collection_statute',\n",
        "    'n_total_estimated_comment',\n",
        "    'total_method'\n",
        "]\n",
        "\n",
        "# Select columns that exist in the dataset\n",
        "available_columns = [col for col in final_columns if col in sdis_enhanced.columns]\n",
        "sdis_final = sdis_enhanced[available_columns].copy()\n",
        "\n",
        "# Export to CSV\n",
        "output_path = base_dir / \"output\" / \"sdis\" / \"sdis_clean.csv\"\n",
        "sdis_final.to_csv(output_path, index=False)\n",
        "print(f\"Exported enhanced SDIS dataset to: {output_path}\")\n",
        "\n",
        "# Display final summary statistics\n",
        "print(\"\\n\\nFinal Summary Statistics:\")\n",
        "print(\"=\" * 50)\n",
        "print(f\"Total states in dataset: {len(sdis_final)}\")\n",
        "print(f\"States with n_total_estimated: {sdis_final['n_total_estimated'].notna().sum()}\")\n",
        "print(f\"States with n_total_reported: {sdis_final['n_total_reported'].notna().sum()}\")\n",
        "print(f\"Total profiles (estimated): {sdis_final['n_total_estimated'].sum():,.0f}\")\n",
        "\n",
        "# Show comparison of reported vs estimated totals\n",
        "comparison = sdis_final[sdis_final[['n_total_reported', 'n_total_estimated']].notna().all(axis=1)].copy()\n",
        "comparison['difference'] = comparison['n_total_estimated'] - comparison['n_total_reported']\n",
        "comparison_summary = comparison[comparison['difference'] != 0][['state', 'n_total_reported', 'n_total_estimated', 'difference', 'n_total_estimated_comment']]\n",
        "\n",
        "if len(comparison_summary) > 0:\n",
        "    print(\"\\n\\nStates where estimated differs from reported total:\")\n",
        "    display(comparison_summary.style.format({\n",
        "        'n_total_reported': '{:,.0f}',\n",
        "        'n_total_estimated': '{:,.0f}',\n",
        "        'difference': '{:,.0f}'\n",
        "    }).hide(axis='index'))"
      ],
      "id": "290548b8",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}